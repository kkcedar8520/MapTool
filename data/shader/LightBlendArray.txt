#define g_iNumLight  4

struct VS_OUT
{
	float4 p : SV_POSITION;
	float3 n : NORMAL;
	float4 c : COLOR0;
	float2 t : TEXCOORDO;
	float3 world : TEXCOORD1;
	float time : TEXCOORD2;
};

struct VS_IN
{
	float3 p : POINT;
	float3 n : NORMAL;
	float4 c : COLOR;
	float2 t : TEXT;
};

cbuffer m_ConData : register(b0)
{
	float4x4 g_matWorld : packoffset(c0);
	float4x4 g_matView : packoffset(c4);
	float4x4 g_matProj : packoffset(c8);
	float4 time : packoffset(c12);

};

cbuffer m_Light : register(b1)
{
	float4 g_cAmbientLightColor[g_iNumLight];
	float4 g_cDifuseLightColor[g_iNumLight];
	float4 g_cSpecularLightColor[g_iNumLight];
	float4 g_vLightDir[g_iNumLight];	//감쇠
	float4 g_vLightPos[g_iNumLight];	//반지름
	float4 g_vEyeDir[g_iNumLight];	//w 강도
	float4 g_vEyePos[g_iNumLight];	//반지름
	float4 g_vSpot[g_iNumLight];
};


float4 Diffuse(float3 vNormal,int i)
{
	float4 Color = float4(0,0,0,0);
	//for(int i=0; i<g_iNumLight; i++)
	
		float fdot = max(0, dot(vNormal, normalize(-g_vLightDir[i].xyz)));
		Color = g_cAmbientLightColor[i] + fdot * g_cDifuseLightColor[i];
	
	Color.w = 1.0f;
	return Color;
}

float4 Specular(float3 vNormal, int i)
{
	float4 Color = float4(0,0,0,0);
	//for(int i=0; i<g_iNumLight; i++)
	
		float3 vReflect = reflect(g_vLightDir[i].xyz, vNormal);
		float fdot = max(0, dot(vReflect, normalize(-g_vEyeDir[i].xyz)));
		float fPower = pow(fdot,g_vEyeDir[i].w);
		Color = fPower * g_cSpecularLightColor[i];
	
	Color.w = 1.0f;
	return Color;
}

//vPos = world
float4 ComputePointLight(float3 vPos, float3 vNormal, int i)
{
	float4 Color = float4(0,0,0,0);
	//for(int i=0; i<g_iNumLight; i++)
	
		float Distance = distance(vPos,g_vLightPos[i].xyz);

		// (min)a~b(max), t의 값
		float offset = smoothstep( Distance-30 , Distance , g_vLightPos[i].w);
		float fdot = saturate(dot(vNormal, -g_vLightDir[i].xyz));
		Color = (offset * fdot * float4(1,0,1,1)) + (Specular(vNormal,i) * offset);
		//g_cDifuseLightColor[i]
		
	
	Color.w=1;
	return Color;

}

float4 ComputeSpotLight(float3 vPos, float3 vNormal, int i)
{
	float4 Color = float4(0,0,0,0);
	//for(int i=0; i<g_iNumLight; i++)
	
		float Distance = distance(vPos,g_vLightPos[i].xyz);
		float4 fDiffuse = g_cDifuseLightColor[i];

		float fInner = g_vSpot[i].x;
		float fOutner = g_vSpot[i].y;
		float fFalloff = g_vSpot[i].z;
		float fRange = g_vLightPos[i].w;

		float3 vLight = normalize(vPos-g_vLightPos[i].xyz );
		float fDot = saturate(dot(g_vLightDir[i].xyz, vLight));
		float fOffset =smoothstep( Distance - fFalloff , Distance , fRange);
		if(fDot > fInner)
		{
		
			return Color=fDiffuse *fOffset;
		}
		else if(fDot > fOutner)
		{
			float fPhi = fOutner-fInner;
			float fValue = 1.0f-((fDot-fInner)/fPhi);
			return Color = fDiffuse * fValue * fOffset;
		}
		else
		{
			return Color = float4(0,0,0,1);
		}
	
	//return Color;

}

VS_OUT VS(VS_IN data)
{
	VS_OUT vout;
	vout.p = float4(data.p, 1.0f);
	vout.n = data.n;
	vout.c = data.c;
	vout.t = data.t;
	return vout;
}

VS_OUT VSmat(VS_IN data)
{
	VS_OUT vout;
	float4 vLocal = float4(data.p, 1.0f);
	float4 vWorld = mul(vLocal, g_matWorld);
	float4 vView = mul(vWorld, g_matView);
	float4 vProj = mul(vView, g_matProj);
	vout.p = vProj;
	vout.n = data.n;
	vout.world = vWorld.xyz;
	//vout.world.x = vWorld.x;
	//vout.world.y = vWorld.y;
	//vout.world.z = vWorld.z;
	//vout.c = ComputePointLight(vWorld.xyz, vout.n);//+Specular(vout.n); //Diffuse(vout.n)
	vout.t = data.t*10;
	return vout;
}



Texture2D		g_txDiffuseA : register(t0);
Texture2D		g_txDiffuseB : register(t1);
SamplerState	g_Sample0 : register(s0);

struct PS_IN
{
	float4 p : SV_POSITION;
	float3 n : NORMAL;
	float4 c : COLOR0;
	float2 t : TEXCOORDO;
	float3 world : TEXCOORD1;
	float time : TEXCOORD2;
};

struct PS_OUT
{
	float4 add : SV_TARGET0;
	float4 mul : SV_TARGET1;
};

PS_OUT PS(PS_IN vsdata)
{
	PS_OUT pout;
	float4 FinalA = g_txDiffuseA.Sample(g_Sample0, vsdata.t);

	pout.add = FinalA;
	return pout;
}

PS_OUT PSLight(PS_IN vsdata)
{
	PS_OUT pout;
	//float4 FinalA = g_txDiffuseA.Sample(g_Sample0, vsdata.t)*vsdata.c;
	float4 FinalA = float4(0,0,0,0);
	for(int i=0; i<g_iNumLight; i++)
	{
		if(g_vSpot[i].w==1)
		{
			FinalA += g_txDiffuseA.Sample(g_Sample0, vsdata.t) * (g_cAmbientLightColor[i] + ComputeSpotLight(vsdata.world, vsdata.n, i));//+Specular(vsdata.n));
		}
		else if(g_vSpot[i].w==0)
		{
			FinalA += g_txDiffuseA.Sample(g_Sample0, vsdata.t) *( g_cAmbientLightColor[i] + ComputePointLight(vsdata.world, vsdata.n, i));//+Specular(vsdata.n,i));
		}
	}
	FinalA.w=1;
	pout.add = FinalA;
	//pout.add=vsdata.c;
	return pout;
}

PS_OUT PSBlend(PS_IN vsdata)
{
	PS_OUT pout;
	float4 FinalA = g_txDiffuseA.Sample(g_Sample0, vsdata.t);
	float4 FinalB = g_txDiffuseB.Sample(g_Sample0, vsdata.t);
	float alpha=(FinalA.r+FinalA.g+FinalA.b)/3;
	pout.mul=float4(1-alpha,1-alpha,1-alpha,alpha);
	pout.add=lerp(FinalA,FinalB,vsdata.time);
	return pout;
}

PS_OUT PSBlend2(PS_IN vsdata)
{
	PS_OUT pout;
	float4 SRC = g_txDiffuseA.Sample(g_Sample0, vsdata.t);
	if(SRC.x == 1.0f)
	{
		if(SRC.y == 1.0f)
		{
			if(SRC.z == 1.0f)
			{
				SRC.w=0.0f;
			}
		}
	}

	pout.add = SRC;
	return pout;
}